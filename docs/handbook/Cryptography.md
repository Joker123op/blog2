### Base64

目前Base64已经成为网络上常见的传输8Bit字节代码的编码方式之一。在做支付系统时，系统之间的报文交互都需要使用Base64对明文进行转码，然后再进行签名或加密，之后再进行（或再次Base64）传输。那么，Base64到底起到什么作用呢？

在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。

电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。

---
### Base64的编码原理

Base64的原理比较简单，每当我们使用Base64时都会先定义一个类似这样的数组：
```
['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
```
Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。

Base64的对应索引值如下

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271041005.webp)

编码时，每 3 个字节一组，共 8bit*3=24bit，划分成 4 组，即每 6bit 代表一个编码后的索引值

划分如下图所示：

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271042400.webp)

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271042445.webp)

可以看到 cat 编码后变成了 Y2F0。

如果待编码内容的字节数不是 3 的整数倍，那需要进行一些额外的处理。

如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 =：

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271043759.webp)

如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 =：

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271043411.webp)


### 个人的通俗理解

Base64的本质其实就是将需要加密的字符转化为这个字符的二进制ASCII码。

而二进制的ASCII码刚刚好对应8位,而Base64是以6个二进制为一位。

如果加密的原文不够24bit，最后会以==做替补。

编码的过程中就是将需加密的原文转换为2进制的ASCII码，然后每6个相邻的二进制数转化为十进制

这个转化后的十进制就刚刚好对应的是Base64的索引值，即可成功加密。

如果遇见位数不足的情况下则补0处理，如果一个字节里全是也就是空的情况下，补一个=

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271058222.webp)

### 使用Python自带的库可以快速简便的将base64加解密

源码：

```Python
import base64


def encode_base64(string_1: str) -> str:
    input_bytes = string_1.encode('utf-8')
    encoded_bytes = base64.b64encode(input_bytes)
    return encoded_bytes.decode('utf-8')


def decode_base64(string_2: str) -> str:
    encoded_bytes = string_2.encode('utf-8')
    decoded_bytes = base64.b64decode(encoded_bytes)
    return decoded_bytes.decode('utf-8')


while True:
    if __name__ == '__main__':
        print("注：如果解不出则是base64编码格式有误")
        choice = input('请选择编码 (e) 或解码 (d): ')
        if choice == 'e':
            string_1 = input('请输入要编码的字符串: ')
            print(encode_base64(string_1))
            xml3 = str(input("继续(1)\n退出(0)"))
            if xml3 == '1':
                pass
            elif xml3 == '0':
                break
            else:
                xml3 = input('无效选择,按回车键自动重启')
                pass
        elif choice == 'd':
            string_2 = input('请输入要解码的 base64 字符串: ')
            print(decode_base64(string_2))
            xml = int(input("继续(1)\n退出(0)"))
            if xml == '1':
                pass
            elif xml == '0':
                break
            else:
                xml = input('无效选择,按回车键自动重启')
        else:
            print('无效选择')
            xml2 = str(input("继续(1)\n退出(0)"))
            if xml2 == '1':
                pass
            elif xml2 == '0':
                break
            else:
                xml2 = input('无效选择,按回车键自动重启')
                pass
```


## RSA加解密原理

CTF密码学类题目中，RSA加密可谓是很重要且常见的加密类型，今天就总结下 RSA加密的原理及解密方法。

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271604260.webp)

### 加密过程

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271605859.webp)


### RSA算法简介：

* RSA加密算法是属于非对称加密算法的一种，相比起对称加密的MD5算法来说，他具有可逆的优点

### 数学基础

#### 一、素数

素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。

#### 二、模运算

* 模运算即求余运算。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余数，则二整数同余。

* 两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b \ (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 \ (mod 12)。

#### 三、互质关系

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。

由互质关系，得到以下结论：

* 任意两个质数构成互质关系，比如17和53。
* 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10.
* 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57.
* 1和任意一个自然数都是互质关系，比如1和88。
* p是大于一的整数，则p和p-1构成互质关系，比如57和56。
* p是大于一的奇数，则p和p-2构成互质关系，比如17和15。

#### 四、欧拉函数

假如任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？)

计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。

φ(n)的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。

##### 第一种情况

如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。

##### 第二种情况

如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。

##### 第三种情况

如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271452217.webp)

比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。

这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。

上面的式子还可以写成下面的形式：

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271453181.webp)

可以看出，上面的第二种情况是 k=1 时的特例。

#### RSA算法

密钥生成步骤

##### 第一步，随机选择两个不相等的质数p和q。

假设选择61和53。（实际这两个数越大越难破解）

##### 第二步，计算pq的乘积n。

> n = 61 x 53 = 3233

n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。

##### 第三步，计算n的欧拉函数φ(n)。

> φ(n) = φ(p*q) = (p-1)(q-1)

φ(n) 表示：在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。

例：

在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。