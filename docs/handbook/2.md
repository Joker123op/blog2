# Base64
## Base64的由来
>目前Base64已经成为网络上常见的传输8Bit字节代码的编码方式之一。在做支付系统时，系统之间的报文交互都需要使用Base64对明文进行转码，然后再进行签名或加密，之后再进行（或再次Base64）传输。那么，Base64到底起到什么作用呢？

在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。

电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。

---
## Base64的编码原理
Base64的原理比较简单，每当我们使用Base64时都会先定义一个类似这样的数组：
```
['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
```
Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。

Base64的对应索引值如下

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271041005.webp)

编码时，每 3 个字节一组，共 8bit*3=24bit，划分成 4 组，即每 6bit 代表一个编码后的索引值

划分如下图所示：

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271042400.webp)

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271042445.webp)

可以看到 cat 编码后变成了 Y2F0。

如果待编码内容的字节数不是 3 的整数倍，那需要进行一些额外的处理。

如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 =：

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271043759.webp)

如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 =：

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271043411.webp)


## 个人的通俗理解

Base64的本质其实就是将需要加密的字符转化为这个字符的二进制ASCII码。

而二进制的ASCII码刚刚好对应8位,而Base64是以6个二进制为一位。

如果加密的原文不够24bit，最后会以==做替补。

编码的过程中就是将需加密的原文转换为2进制的ASCII码，然后每6个相邻的二进制数转化为十进制

这个转化后的十进制就刚刚好对应的是Base64的索引值，即可成功加密。

如果遇见位数不足的情况下则补0处理，如果一个字节里全是也就是空的情况下，补一个=

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202303271058222.webp)

## 使用Python自带的库可以快速简便的将base64加解密

源码：

```Python
import base64


def encode_base64(string_1: str) -> str:
    input_bytes = string_1.encode('utf-8')
    encoded_bytes = base64.b64encode(input_bytes)
    return encoded_bytes.decode('utf-8')


def decode_base64(string_2: str) -> str:
    encoded_bytes = string_2.encode('utf-8')
    decoded_bytes = base64.b64decode(encoded_bytes)
    return decoded_bytes.decode('utf-8')


while True:
    if __name__ == '__main__':
        print("注：如果解不出则是base64编码格式有误")
        choice = input('请选择编码 (e) 或解码 (d): ')
        if choice == 'e':
            string_1 = input('请输入要编码的字符串: ')
            print(encode_base64(string_1))
            xml3 = int(input("继续(1)\n退出(0)"))
            if xml3 == 1:
                pass
            elif xml3 == 0:
                break
            else:
                xml3 = input('无效选择,按回车键自动重启')
                pass
        elif choice == 'd':
            string_2 = input('请输入要解码的 base64 字符串: ')
            print(decode_base64(string_2))
            xml = int(input("继续(1)\n退出(0)"))
            if xml == 1:
                pass
            elif xml == 0:
                break
            else:
                xml = input('无效选择,按回车键自动重启')
        else:
            print('无效选择')
            xml2 = int(input("继续(1)\n退出(0)"))
            if xml2 == 1:
                pass
            elif xml2 == 0:
                break
            else:
                xml2 = input('无效选择,按回车键自动重启')
                pass

```
