## XSS注入简介

XSS简介

* SQL注入就是将用户输入的数据被当作SQL代码执行

* XSS(前端代码注入)

前端代码（开源）三块
1. HTML：网页的框架
2. CSS：把网站变得更加好看
3. Javascript：让网页功能更强大

对于攻击者而言CSS并不重要，因为他只是美化界面，并没有安全效果

攻击的方向是js和如何触发js。因为js很强大，它可以控制浏览器

* `document.cookie="id"`(设置浏览器Cookie的js代码)
* 偷偷发送数据包(异步传输)
* 它可以窃取Cookie (先读取你的Cookie然后偷偷发送数据包给黑客，黑客收到Cookie后就可以登录你的账户)

拿到Cookie不等于拿到密码。（Cookie授权是有时效的）Cookie本身是不安全的，但是为了便捷并且利大于弊的情况下就选择了Cookie

Js的标识：
```JS
<script>alert(1)</script> // 设置了一个js弹窗

<a href=javascript:alert(1)> // 伪协议触发

<img src=1 onerror=alert(1) /> // 事件方法（触发器：事件在标签里面on开头的东西很高概率是事件）触发条件是src=1，因为这个本身不成立所以执行了后面的语句
```

上面三个不仅仅是js的标识还是触发的方法

[JavaScript事件触发手册](https://blog.csdn.net/qq_36354324/article/details/106592588)

有的时候是缓存问题导致无法弹窗CTRL+F5就行了

事件功能非常强大，甚至可以监听键盘鼠标，左键右键，屏幕。

XSS分为三种类型：

* 反射型：你给我传参，然后触发了Js，如果你不给我传参，就不存在(传参里必须包含恶意语句才是标准的反射性XSS语句)
* 存储型：存储下来的传参，不需要传参中必须有恶意语句。但这样的脚本会被存进数据库，在这之后的所有人在访问这个网站的时候都有可能会执行你写的xss脚本(只要他存储在目标服务器)

存储型的xss脚本的功能是十分强大的，如果有人在网站的数据库里打入了一个存储型的xss脚本，并且它会获取每个用户的Cookie，那么他就会有盗号等一系列的风险

反射性的xss要点击才会中招

`http://www.xxx.com/?a=<script>alert(1)</script>`这就是一个反射性xss脚本，正常人看见都觉得肯定有问题，所以就可以引入一个东西

叫做短链接，原理很简单，在百度随便一搜就大把多。可以把长链接压缩成短链接，这样就可以引导别人点击。

在实际网站中也会遇见尖括号被编码掉了导致无法注入

前端代码有一个很重要的东西是**兼容性**。会对一些东西进行包容

JavaScript还支持一些编码例如：NATIVE

弹窗函数被劫栏会尝试替代`prompt(1)`

`payload:'onfocus=alert(1)autofocus'当input输入框获取焦点时执行(onfocus)`

## Cookie同源策略

浏览器的同源策略，限制了不同源的JS，对当前页面的资源和属性的权限。同源策略保护了a.com域名下的资源不被来自其他网页的脚本读取或篡改

所谓同源是：需要同域名/端口、协议

比如
`http://www.baidu.com`

`https://www.baidu.com`

就不是同源的

Js偷Cookie就是读取本地的Cookie发送到我准备好的目标服务器上

[XSS平台](https://xssaq.com/)域名做越短越好

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202304181445728.webp)

如果只是窃取Cookie勾选这两个就已经够了

给网站添加cookie或者更改的插件是`EditThisCookie`下载地址放这里了[跳转](https://github.com/ETCExtensions/Edit-This-Cookie/releases/tag/1.5.0)

存储型XSS会出现的地方：

* 任何可能插入数据库的地方
* 用户注册的时候
* 留言板
* 上传文件的文件名
* （管理员可见的）报错信息

一般情况下来说前台的防御是高于后台的

存储型xss：

1. 同源法则
2. XSS平台
3. 存储型XSS并不是非得存数据库
4. XSS可以见框就插

## Dom Based XSS

Dom是一个Js可以操控浏览器和网页的接口

Dom不会经过服务器，本质上是自己打自己，因为每次有用户访问网站都会需要服务器对他分配一定资源，如果是有100万人同时访问，甚至更多。就会导致服务器压力过大。

所以这个时候就需要经过用户自己的本地，可以一定程度上给服务器减轻一部分压力，所以产生了漏洞

每个载入浏览器的HTML文档都会成为Document对象。

Document对象使我们可以从脚本中对HTML页面中的所有元素进行访问。

Document的对象属性

| 属性 | 描述 |
| -- | -- |
| body | 提供对`<body>`元素的直接访问。对于定义了框架集的文档，该属性引用最外层的`<frameset>` |
| cookie | 设置或返回与当前文档有关的所有cookie |
| domain | 返回当前文档的域名 |
| lastModified | 返回文档被修改的最后日期和时间。 |
| referrer | 返回载入当前文档的文档url。 |
| title | 返回当前文档的标题。 |
| URL | 返回当前文档的URL， |

这是上述函数的使用方法

| 函数 | 作用 |
| -- | -- |
| document.body | 提取Body信息 |
| document.domain | 提取当前页面域名 |
| document.lastModified | 查看当前页面的最后修改时间（同时也可以查看网站是否是静态网站） |

详细内容可以看看这篇扩展文章[Dom Based XSS](https://blog.csdn.net/weixin_45634365/article/details/114536958)

在真是网络环境中，还会存在一些伪静态网页，他们本质上还是动态。一样可以进行SQL注入。判断方法是使用函数`document.lastModified`来查看

要依靠当前页面JS才能触发的漏洞，可以理解为dom型xss


## CSRF

CSRF跨站请求伪造：也被称为“One Click Attack”或者Seccion Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(xss)，但是他和xss非常不同，xss利用站点内的信任用户，而CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比xss更具危险性

CSRF漏洞的成因是因为网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的CSRF脚本或者包含CSRF脚本的链接，可能会执行一些用户不想做的功能(比如是添加账号等)

CSRF和XSS没有直接关系

XSS：在目标网页上执行JS来窃取Cookie

CSRF：危害很大，但是条件需要配合

* 1、恰好登陆
* 2、好登陆了

生成一个CSRF攻击的html文件很简单，先在自己需要强制发送的数据包进行自己修改一下，再使用burpsutie进行抓包，然后右键

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202304201602036.webp)

然后就会会生成一个html，把他保存下来就可以形成一个可以攻击的恶意CSRF

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202304201603487.webp)

## 文件上传漏洞

只要能在目标服务器上放一个一句话木马，是不是就代表我们获取了一定权限

一句话木马

```PHP
<?php eval($_REQUEST[8]); ?>
```

如果没有防护规则的文件上传：

只要上传一个php就可以拿下目标

检测恶意代码：

前端检测：Js = 没有检测因为js可以被自己禁用，而且可以使用burp suite进行篡改js
前端代码只能在浏览器里执行

---

后端检测：后端PHP。利用黑白名单机制

黑名单：不允许黑名单上的东西上传

白名单：只允许黑名单上的东西上传(这种相对于白名单机制的防范效果更好)

判断网站上传黑白名单的机制的办法就是随便上传一个后缀名例如`.a` `.b`上传一些根本就不存在的后缀看看是否能上传成功。如果上传成功证明网页是用的是黑名单机制

在网站中php、js、asp都有属于自己的别民，这样上传之后一样会当作代码执行

---

.htaccess文件绕过。全程是Hypertext Access(超文本入口).htaccess文件也被分成为分布式配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录

.htaccess功能：
文件夹密码保护、用户自定义重定向、自定义404页面、扩展名为静态化、静止特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表

很可惜，这么一个强大的功能默认是不开启Apache（有伪静态的会开启）

例如：`AddType addlication/x-httpd-php.jpg`这个指令代表着.jpg文件会当作php来解析

如果无法将文件命名为.htaccess怎么办

使用cmd进行重命名

```CMD
ren 17.txt .htaccess
```

在Windows里php == php+空格

但是在后端是无法检测的，在后端中 php != php+空格

文件上传的流程

文件上传 -> 检测 -> 上传到缓存文件(tmp) -> 后端代码的移动，移动到指定的目录重命名

### Windows文件流绕过

Windows里有一个骚操作就是隐藏文件

```
echo 123123 > caidao.exe:123.txt

caidao.exe:123.txt
```

将冒号后面的文件依附在前面的文件之中

而且无法看出来，打开附属文件的方法是使用cmd打开

在win里面保存文件的格式是`777.txt::$DATA`保存文件的时候默认情况下会加上这一串

这对于Windows来说两个是一样的，但是对于后端来说他就是两个东西

上传文件的流程：

网页上传 -> 目标服务器缓存 -> 移动到开发写好的地址 -> 重命名(开发)

白名单上传相对于黑名单来说会更加麻烦一点，但是作为渗透人员就是要不断的绕过别人的防御

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202304212349857.webp)

这种方法也是绕过的一种方法

有的时候后端还会检查你的jpg文件头是否匹配，如果不匹配，即使你是jpg结尾也无法上传

解决方法：图片木马

* 图片木马就可以把图片和一句话木马结合到一起变成图片木马

操作就是随便找一张图片，然后再创建一个txt文件，在这个文件里面写上一句话木马`<?php @eval($_REQUEST[8]); ?>`

然后把这两个文件放在同一个目录下，然后打开cmd输入命令

```
copy (文件名).jpg/b + (一句话木马的文件名).txt (生成的木马图片名称).jpg

实例：

copy 1.jpg/b + a.txt 123.jpg
```

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202304220004269.webp)

不过这样生成的一句话木马就放在图片的16进制最下面，有的时候安全防护这边也会对其进行防护，这个时候就可以使用复合图片的形式

A图片 + 一句话木马 + A图片 

### 00截断

### 二次渲染

二次渲染的意思就是，当你上传的文件是图片类型的时候，他会照着你的图片，给你画一个一模一样的上传服务器，而不是直接上传你的源文件

在文件上传过程中，如果是上传图片类型的，有时会遇见二次渲染。这个时候，无论怎么在图片里做手脚都无济于事。

上传的图片类型文件越小越好


不过一样有个解决方法，就是在上传一个gif文件，然后在开头处手动写一个一句话木马(最好是在文件的第三行开始写)

### 条件竞争

文件上传的检测流程：

* 先检测后上传


* 先上传后检测

如果我们上传的速度够快电脑来不及删除，那就意味着我上传成功。电脑就会被植入木马

但是如果刚连接上就被删了也没意义。所以这个时候就可以对php里的内容做手脚

在php里让php帮我们写一个马然后存在本地，这样不就绕过了

这时候就需要认识一下[php的文件操作](https://www.w3school.com.cn/php/php_file_create.asp)方法

解析漏洞

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202304230930103.webp)

同一环境下的网站他可能即支持php也支持asp。环境是可以混合的而且这种还是很常见的

一般来说aspx的站点会兼容ASP

asp一句话木马

```ASP
<%eval request("a")%>
```

### PHP CGI解析漏洞

php和web容器交互是有两种方法的

![Img](https://joker-1317382260.cos.ap-guangzhou.myqcloud.com/202304231916418.webp)

如何判断一个网页是否存在CGI漏洞？

> 随便寻找任意的一个站点，复制他的图片然后在url上加上`/.php`如果页面出现乱码，就证明他存在CGI漏洞 

一般情况下渗透需要信息收集

`|IP|端口|路径|旁站|中间件版本|指纹识别|Whois`

渗透测试： 测试 -> 尝试 -> 你需要花费大量的时间和精力

`状态码： 403 404 401 302 200 500(502) 304`

这是有关于[状态码的扩展](https://www.runoob.com/http/http-status-codes.html)

挖洞、细心


| TH |
| -- |
| TD | TD | TD |













